# Тема 10. Декораторы и исключения.
Отчет по Теме #10 выполнил:
- Михеев Владислав Вячеславович
- ЗПИЭ-20-2

| Задание | Сам_раб |
| ------ | ------ |
| Задание 1 | + |
| Задание 2 | + |
| Задание 3 | + |
| Задание 4 | + |
| Задание 5 | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Самостоятельная работа №1
### Вовочка решил заняться спортивным программированием на python, но для этого он должен знать за какое время выполняется его программа. Он решил, что для этого ему идеально подойдет декоратор для функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор.

```python
import time


def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"\nВремя выполнения функции {func.__name__}: {execution_time} секунд")
        return result

    return wrapper


@timing_decorator
def fibonacci():
    fib1 = fib2 = 1
    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end=" ")


if __name__ == "__main__":
    fibonacci()
```

### Результат.
![Меню](https://github.com/vm24402/piton/blob/%D1%82%D0%B5%D0%BC%D0%B0-10/pic/Screenshot_1.jpg)

## Выводы

В данном коде выводятся две строки с использованием функции `print()`. Каждая строка содержит разные значения:

1. ` print(f"\nВремя выполнения функции {func.__name__}: {execution_time} секунд")`: Выводит время выполнения функции.

2. `print(fib2, end=" ")`: Выводит числа Фибоначчи.

## Самостоятельная работа №2
### Посмотрев на Вовочку, вы также загорелись идеей спортивного программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение (“бросить исключение”) и вывести в консоль “файл пустой”, а если он не пустой, то вывести информацию из файла.

```python
def read_file(filename: str) -> None:
    try:
        with open(filename, "r") as file:
            data = file.read()
    
            if not data:
                raise Exception("файл пустой")
    
            print(f"Содержимое файла:\n{data}")
    except FileNotFoundError:
        print("Файл не найден")
    except Exception as e:
        print(f"Ошибка: {e}")
read_file("filename.txt")
```

### Результат.
![Меню](https://github.com/vm24402/piton/blob/%D1%82%D0%B5%D0%BC%D0%B0-10/pic/Screenshot_2.jpg)

## Выводы

В данном коде выводятся три строки с использованием функции `print()`. Каждая строка содержит разные значения:

1. `print(f"Содержимое файла:\n{data}")`: Выводит содержимое файла.

2. `print("Файл не найден")`: Выводит файл не найден.

3. `print(f"Ошибка: {e}")`: Выводит "Ошибка".

## Самостоятельная работа №3
### Напишите функцию, которая будет складывать 2 и введенное пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка “Неподходящий тип данных. Ожидалось число.”. Реализовать функционал программы необходимо через try/except и подобрать правильный тип исключения. Создавать собственное исключение нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. Результатом выполнения задачи будет листинг кода и получившийся вывод в консоль

```python
def add_two_numbers():
    try:
        user_input = input("Введите число: ")
        number = float(user_input)
        result = 2 + number
        print("Результат сложения:", result)
    except ValueError:
        print("Неподходящий тип данных. Ожидалось число.")


if __name__ == "__main__":
    try:
        add_two_numbers()
    except KeyboardInterrupt:
        print("\nПрограмма завершена.")
```

### Результат.
![Меню](https://github.com/vm24402/piton/blob/%D1%82%D0%B5%D0%BC%D0%B0-10/pic/Screenshot_3.jpg)


## Выводы

В данном коде выводятся три строки с использованием функции `print()`. Каждая строка содержит разные значения:

1. `print("Результат сложения:", result)`: Выводит результат сложения.

2. `print("Неподходящий тип данных. Ожидалось число.")`: Выводит непододящий тип данных.

3. `print("\nПрограмма завершена.")`: Выводит программа завершена.

## Самостоятельная работа №4
### Создайте собственный декоратор, который будет использоваться для двух любых вами придуманных функций. Декораторы, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс декоратора, две как-то связанными с ним функциями, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.
```python
import functools

# Создаем декоратор log_args для логирования аргументов функции
def log_args(func):
    @functools.wraps(func)  # Сохраняем метаданные функции
    def wrapper(*args, **kwargs):
        # Собираем строковое представление позиционных аргументов
        arg_str = ", ".join([repr(arg) for arg in args])
        # Собираем строковое представление именованных аргументов
        kwarg_str = ", ".join([f"{k}={v!r}" for k, v in kwargs.items()])
        
        # Объединяем строки, если оба типа аргументов присутствуют
        if arg_str and kwarg_str:
            arg_str += ", " + kwarg_str
        elif kwarg_str:
            arg_str = kwarg_str
        
        # Выводим информацию о вызове функции с аргументами
        print(f"Вызов функции {func.__name__}({arg_str})")
        
        # Вызываем исходную функцию и сохраняем результат
        result = func(*args, **kwargs)
        
        # Возвращаем результат выполнения функции
        return result

    # Возвращаем обернутую функцию
    return wrapper

# Применяем декоратор log_args к функции add
@log_args
def add(a, b):
    return a + b

# Применяем декоратор log_args к функции greet
@log_args
def greet(name):
    return f"Привет, {name}!"

if __name__ == "__main__":
    # Вызываем функцию add с аргументами 2 и 3
    result1 = add(2, 3)
    
    # Вызываем функцию greet с аргументом "Alice"
    result2 = greet("Alice")
```

### Результат.
![Меню](https://github.com/vm24402/piton/blob/%D1%82%D0%B5%D0%BC%D0%B0-10/pic/Screenshot_4.jpg)

## Самостоятельная работа №5
### Создайте собственное исключение, которое будет использоваться в двух любых фрагментах кода. Исключения, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс исключения, код к котором в двух местах используется это исключение, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.

```python
# Создаем пользовательское исключение CustomException,
# которое будет использоваться для обработки специфических ошибок.
class CustomException(Exception):
    def __init__(self, message="Произошла ошибка"):
        self.message = message
        super().__init__(self.message)

# Функция divide(a, b) выполняет деление двух чисел a на b.
# Если b равно 0, то возбуждается исключение CustomException с сообщением "Деление на ноль недопустимо".
# В противном случае возвращается результат деления a на b.
def divide(a, b):
    if b == 0:
        raise CustomException("Деление на ноль недопустимо")
    return a / b

# Функция process_data(data) принимает входные данные data
# и выполняет какую-либо обработку. Если data пусто, то
# возбуждается исключение CustomException с сообщением "Пустые данные недопустимы".
# В противном случае возвращается сообщение об успешной обработке данных.
def process_data(data):
    if not data:
        raise CustomException("Пустые данные недопустимы")
    return "Данные обработаны успешно"

# Основной блок кода, выполняемый при запуске скрипта.
if __name__ == "__main__":
    try:
        result = divide(10, 0)  # Попытка деления на ноль.
    except CustomException as e:
        print(f"Ошибка: {e}")  # Вывод сообщения об ошибке CustomException.
    else:
        print(f"Результат: {result}")  # Вывод результата деления (не выполнится, так как возникла ошибка).

    try:
        result = process_data([])  # Попытка обработки пустых данных.
    except CustomException as e:
        print(f"Ошибка: {e}")  # Вывод сообщения об ошибке CustomException.
    else:
        print(f"Результат: {result}")  # Вывод сообщения об успешной обработке данных (не выполнится, так как возникла ошибка).
```

### Результат.
![Меню](https://github.com/vm24402/piton/blob/%D1%82%D0%B5%D0%BC%D0%B0-10/pic/Screenshot_5.jpg)
